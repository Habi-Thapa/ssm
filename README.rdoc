= SimpleStateMachine

A simple DSL to decorate existing methods with state transition guards.

Instead of using a DSL to define events, SimpleStateMachine decorates methods 
to help you encapsulate state and guard state transitions.

It supports exception rescuing, google chart visualization and mountable state machines.


== Installation

Use gem install:

  gem install simple_state_machine

Or add it to your Gemfile:

  gem 'simple_state_machine'


== Basic usage

Define your event as a method, arguments are allowed:

  def activate_account(activation_code)
    # call other methods, no need to add these in callbacks
    ..
  end

Now mark the method as an event and specify how the state should transition 
when the method is called. If we want the state to change from :pending to :active we write:

  event :activate_account, :pending => :active

That's it!
You can now call activate_account and the state will automatically change.
If the state change is not allowed, a SimpleStateMachine::IllegalStateTransitionError is raised.


== Basic example

  class LampSwitch

     extend SimpleStateMachine

     def initialize
       self.state = 'off'
     end

     def push_switch
       puts "pushed switch"
     end
     event :push_switch, :off => :on,
                         :on  => :off

  end

  lamp = LampSwitch.new
  lamp.state          # => 'off'
  lamp.off?           # => true
  lamp.push_switch    # => 'pushed switch'
  lamp.state          # => 'on'
  lamp.on?            # => true
  lamp.push_switch    # => 'pushed switch'
  lamp.off?           # => true


== ActiveRecord Example

To add a state machine to an ActiveRecord class, you will have to:
- extend SimpleStateMachine::ActiveRecord,
- set the initial state in after_initialize,
- turn methods into events

    class User < ActiveRecord::Base

      extend SimpleStateMachine::ActiveRecord

      def after_initialize
        self.ssm_state ||= 'pending'
       end

      def invite
        self.activation_code = Digest::SHA1.hexdigest("salt #{Time.now.to_f}")
      end
      event :invite, :pending => :invited

      def confirm_invitation activation_code
        if self.activation_code != activation_code
          errors.add 'activation_code', 'is invalid'
        end
      end
      event :confirm_invitation, :invited => :active
    end

This generates the following event methods
- invite              (behaves like ActiveRecord save )
- invite!             (behaves like ActiveRecord save!)
- confirm_invitation  (behaves like ActiveRecord save )
- confirm_invitation! (behaves like ActiveRecord save!)

And the following methods to query the state:
- pending?
- invited?
- active?

If you want to be more verbose you can also use:
- invite_and_save  (alias for invite)
- invite_and_save! (alias for invite!)


== ActiveRecord Mountable Example

If you like to separate your state machine from your model class, you can do so as following:

  class MyStateMachine < SimpleStateMachine::StateMachineDefinition

    def add_events
      define_event(:invite,             :new     => :invited)
      define_event(:confirm_invitation, :invited => :active)
    end

    def decorator_class
      SimpleStateMachine::Decorator
    end
  end

  class User < ActiveRecord::Base

    extend SimpleStateMachine::Mountable
    mount_state_machine MyStateMachine

    def after_initialize
      self.state ||= 'new'
    end

  end


== Using ActiveRecord / ActiveModel validations

When using ActiveRecord / ActiveModel you can add an error to the errors object:

  def activate_account(activation_code)
    if activation_code_invalid?(activation_code)
      errors.add(:activation_code, 'Invalid')
    end
  end

  activate_account!("INVALID_CODE") # => ActiveRecord::RecordInvalid, "Validation failed: Activation code is invalid"

This will prevent the state from being changed.


== Catching exceptions

You can let the state machine handle exceptions by specifying the failure state for an Error:

  def download_data
    Service.download_data
  end
  event :download_data, :pending => :downloaded,
        Service::ConnectionError => :download_failed

  download_data # catches Service::ConnectionError
  state         # => "download_failed"


== Catching all from states
If an event should transition from all other defined states, you can use :all as from state:

  event :suspend, :all => :suspended


== Generating state diagrams

When using Rails/ActiveRecord you can generate a state diagram of the state machine via the
built in rake tasks.
For details run:
  
  rake -T ssm


== Note on Patches/Pull Requests

* Fork the project.
* Make your feature addition or bug fix.
* Add tests for it. This is important so I don't break it in a
  future version unintentionally.
* Commit, do not mess with rakefile, version, or history.
  (if you want to have your own version, that is fine but bump version in a commit by itself I can ignore when I pull)
* Send me a pull request. Bonus points for topic branches.


== Copyright

Copyright (c) 2010 Marek & Petrik. See LICENSE for details.
